{"version":3,"file":"validation.js","sourceRoot":"","sources":["../src/validation.ts"],"names":[],"mappings":"AAAA,qDAAqD;AACrD,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAE3C;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,UAAU,mBAAmB,CAAC,MAA+B;IACjE,2BAA2B;IAC3B,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,MAAM,IAAI,eAAe,CAAC,0CAA0C,EAAE;YACpE,MAAM;SACP,CAAC,CAAC;IACL,CAAC;IAED,yBAAyB;IACzB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,MAAM,IAAI,eAAe,CAAC,8BAA8B,EAAE;YACxD,YAAY,EAAE,CAAC;SAChB,CAAC,CAAC;IACL,CAAC;IAED,gEAAgE;IAChE,IAAI,MAAM,CAAC,MAAM,GAAG,KAAK,EAAE,CAAC;QAC1B,MAAM,IAAI,eAAe,CAAC,sCAAsC,EAAE;YAChE,YAAY,EAAE,MAAM,CAAC,MAAM;YAC3B,SAAS,EAAE,KAAK;SACjB,CAAC,CAAC;IACL,CAAC;IAED,mCAAmC;IACnC,MAAM,gBAAgB,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAEtE,IAAI,gBAAgB,EAAE,CAAC;QACrB,MAAM,IAAI,eAAe,CAAC,wCAAwC,EAAE;YAClE,YAAY,EAAE,MAAM,CAAC,MAAM;SAC5B,CAAC,CAAC;IACL,CAAC;AACH,CAAC;AAED;;;;;;;;;;;;;;;GAeG;AACH,MAAM,UAAU,kBAAkB,CAAC,UAAkB;IACnD,qCAAqC;IACrC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC;QAClC,MAAM,IAAI,eAAe,CAAC,gCAAgC,EAAE;YAC1D,UAAU;SACX,CAAC,CAAC;IACL,CAAC;IAED,iEAAiE;IACjE,IAAI,UAAU,GAAG,IAAI,IAAI,UAAU,GAAG,KAAK,EAAE,CAAC;QAC5C,MAAM,IAAI,eAAe,CAAC,+CAA+C,EAAE;YACzE,UAAU;YACV,aAAa,EAAE,IAAI;YACnB,aAAa,EAAE,KAAK;SACrB,CAAC,CAAC;IACL,CAAC;AACH,CAAC;AAED;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,UAAU,eAAe,CAAC,OAAe;IAC7C,kCAAkC;IAClC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,CAAC;QAC/B,MAAM,IAAI,eAAe,CAAC,6BAA6B,EAAE;YACvD,OAAO;SACR,CAAC,CAAC;IACL,CAAC;IAED,oCAAoC;IACpC,iDAAiD;IACjD,IAAI,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC;QACpD,MAAM,IAAI,eAAe,CAAC,+BAA+B,EAAE;YACzD,OAAO;SACR,CAAC,CAAC;IACL,CAAC;IAED,yDAAyD;IACzD,IAAI,OAAO,GAAG,GAAG,IAAI,OAAO,GAAG,IAAI,EAAE,CAAC;QACpC,MAAM,IAAI,eAAe,CAAC,uCAAuC,EAAE;YACjE,OAAO;YACP,UAAU,EAAE,GAAG;YACf,UAAU,EAAE,IAAI;SACjB,CAAC,CAAC;IACL,CAAC;AACH,CAAC","sourcesContent":["// Input validation functions for LoqaAudioDsp module\nimport { ValidationError } from './errors';\n\n/**\n * Validates an audio buffer for DSP processing\n *\n * Checks that the buffer:\n * - Is not null/undefined\n * - Is not empty\n * - Does not exceed maximum size (16384 samples)\n * - Does not contain NaN or Infinity values\n *\n * @param buffer - Audio samples as Float32Array or number[]\n * @throws {ValidationError} if validation fails\n *\n * @example\n * ```typescript\n * const buffer = new Float32Array(1024);\n * validateAudioBuffer(buffer); // Passes if buffer is valid\n * ```\n */\nexport function validateAudioBuffer(buffer: Float32Array | number[]): void {\n  // Check for null/undefined\n  if (!buffer) {\n    throw new ValidationError('Audio buffer cannot be null or undefined', {\n      buffer,\n    });\n  }\n\n  // Check for empty buffer\n  if (buffer.length === 0) {\n    throw new ValidationError('Audio buffer cannot be empty', {\n      bufferLength: 0,\n    });\n  }\n\n  // Check maximum buffer size (16384 samples as per architecture)\n  if (buffer.length > 16384) {\n    throw new ValidationError('Buffer too large (max 16384 samples)', {\n      bufferLength: buffer.length,\n      maxLength: 16384,\n    });\n  }\n\n  // Check for NaN or Infinity values\n  const hasInvalidValues = Array.from(buffer).some((v) => !isFinite(v));\n\n  if (hasInvalidValues) {\n    throw new ValidationError('Buffer contains NaN or Infinity values', {\n      bufferLength: buffer.length,\n    });\n  }\n}\n\n/**\n * Validates a sample rate for audio processing\n *\n * Checks that the sample rate:\n * - Is an integer\n * - Is within the supported range (8000-48000 Hz)\n *\n * @param sampleRate - Sample rate in Hz\n * @throws {ValidationError} if validation fails\n *\n * @example\n * ```typescript\n * validateSampleRate(44100); // Passes\n * validateSampleRate(96000); // Throws ValidationError (too high)\n * ```\n */\nexport function validateSampleRate(sampleRate: number): void {\n  // Check if sample rate is an integer\n  if (!Number.isInteger(sampleRate)) {\n    throw new ValidationError('Sample rate must be an integer', {\n      sampleRate,\n    });\n  }\n\n  // Check if sample rate is within supported range (8000-48000 Hz)\n  if (sampleRate < 8000 || sampleRate > 48000) {\n    throw new ValidationError('Sample rate must be between 8000 and 48000 Hz', {\n      sampleRate,\n      minSampleRate: 8000,\n      maxSampleRate: 48000,\n    });\n  }\n}\n\n/**\n * Validates an FFT size for FFT computation\n *\n * Checks that the FFT size:\n * - Is an integer\n * - Is a power of 2\n * - Is within the supported range (256-8192)\n *\n * @param fftSize - FFT size (must be power of 2)\n * @throws {ValidationError} if validation fails\n *\n * @example\n * ```typescript\n * validateFFTSize(1024); // Passes (power of 2)\n * validateFFTSize(1000); // Throws ValidationError (not power of 2)\n * ```\n */\nexport function validateFFTSize(fftSize: number): void {\n  // Check if FFT size is an integer\n  if (!Number.isInteger(fftSize)) {\n    throw new ValidationError('FFT size must be an integer', {\n      fftSize,\n    });\n  }\n\n  // Check if FFT size is a power of 2\n  // Power of 2 check: (n & (n - 1)) === 0 && n > 0\n  if (fftSize <= 0 || (fftSize & (fftSize - 1)) !== 0) {\n    throw new ValidationError('FFT size must be a power of 2', {\n      fftSize,\n    });\n  }\n\n  // Check if FFT size is within supported range (256-8192)\n  if (fftSize < 256 || fftSize > 8192) {\n    throw new ValidationError('FFT size must be between 256 and 8192', {\n      fftSize,\n      minFFTSize: 256,\n      maxFFTSize: 8192,\n    });\n  }\n}\n"]}